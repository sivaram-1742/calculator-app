<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculator Tests</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 40px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
        }
        .test-section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-case {
            padding: 10px;
            margin: 10px 0;
            border-left: 4px solid #ddd;
            padding-left: 15px;
        }
        .test-case.pass {
            border-color: #4caf50;
            background: #f1f8f4;
        }
        .test-case.fail {
            border-color: #f44336;
            background: #fef1f0;
        }
        .test-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .test-result {
            font-family: monospace;
            font-size: 14px;
            color: #666;
        }
        .summary {
            margin-top: 20px;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 8px;
            font-weight: bold;
        }
        button {
            background: #1976d2;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background: #1565c0;
        }
    </style>
</head>
<body>
    <h1>Calculator Test Suite</h1>
    <button onclick="runAllTests()">Run All Tests</button>
    <div id="results"></div>

    <script>
        // Mini test framework
        class TestRunner {
            constructor() {
                this.tests = [];
                this.results = [];
            }

            test(name, fn) {
                this.tests.push({ name, fn });
            }

            async runAll() {
                this.results = [];

                for (const test of this.tests) {
                    try {
                        await test.fn();
                        this.results.push({ name: test.name, pass: true });
                    } catch (error) {
                        this.results.push({ name: test.name, pass: false, error: error.message });
                    }
                }

                this.displayResults();
            }

            displayResults() {
                const resultsDiv = document.getElementById('results');
                const passed = this.results.filter(r => r.pass).length;
                const total = this.results.length;

                let html = `<div class="summary">Tests: ${passed}/${total} passed</div>`;

                html += '<div class="test-section">';
                this.results.forEach(result => {
                    const status = result.pass ? 'pass' : 'fail';
                    const icon = result.pass ? '✓' : '✗';
                    html += `
                        <div class="test-case ${status}">
                            <div class="test-name">${icon} ${result.name}</div>
                            ${result.error ? `<div class="test-result">Error: ${result.error}</div>` : ''}
                        </div>
                    `;
                });
                html += '</div>';

                resultsDiv.innerHTML = html;
            }
        }

        // Helper function to assert
        function assert(condition, message) {
            if (!condition) {
                throw new Error(message || 'Assertion failed');
            }
        }

        // Create test runner
        const runner = new TestRunner();

        // ===== CALCULATOR TESTS =====

        runner.test('Calculator initializes with zero', () => {
            const calc = createCalculator();
            assert(calc.currentOperand === '0', 'Should start with 0');
            assert(calc.previousOperand === '', 'Previous operand should be empty');
        });

        runner.test('Can append single digit', () => {
            const calc = createCalculator();
            calc.appendNumber('5');
            assert(calc.currentOperand === '5', 'Should display 5');
        });

        runner.test('Can append multiple digits', () => {
            const calc = createCalculator();
            calc.appendNumber('1');
            calc.appendNumber('2');
            calc.appendNumber('3');
            assert(calc.currentOperand === '123', 'Should display 123');
        });

        runner.test('Can append decimal point', () => {
            const calc = createCalculator();
            calc.appendNumber('5');
            calc.appendNumber('.');
            calc.appendNumber('5');
            assert(calc.currentOperand === '5.5', 'Should display 5.5');
        });

        runner.test('Prevents multiple decimal points', () => {
            const calc = createCalculator();
            calc.appendNumber('5');
            calc.appendNumber('.');
            calc.appendNumber('5');
            calc.appendNumber('.');
            assert(calc.currentOperand === '5.5', 'Should only have one decimal point');
        });

        runner.test('Addition works correctly', () => {
            const calc = createCalculator();
            calc.appendNumber('5');
            calc.chooseOperation('+');
            calc.appendNumber('3');
            calc.compute();
            assert(calc.currentOperand === '8', 'Should equal 8');
        });

        runner.test('Subtraction works correctly', () => {
            const calc = createCalculator();
            calc.appendNumber('1');
            calc.appendNumber('0');
            calc.chooseOperation('-');
            calc.appendNumber('3');
            calc.compute();
            assert(calc.currentOperand === '7', 'Should equal 7');
        });

        runner.test('Multiplication works correctly', () => {
            const calc = createCalculator();
            calc.appendNumber('6');
            calc.chooseOperation('*');
            calc.appendNumber('7');
            calc.compute();
            assert(calc.currentOperand === '42', 'Should equal 42');
        });

        runner.test('Division works correctly', () => {
            const calc = createCalculator();
            calc.appendNumber('2');
            calc.appendNumber('0');
            calc.chooseOperation('/');
            calc.appendNumber('4');
            calc.compute();
            assert(calc.currentOperand === '5', 'Should equal 5');
        });

        runner.test('Handles division by zero', () => {
            const calc = createCalculator();
            calc.appendNumber('5');
            calc.chooseOperation('/');
            calc.appendNumber('0');
            calc.compute();
            assert(calc.currentOperand.includes('divide by zero'), 'Should show error message');
        });

        runner.test('Clear resets calculator', () => {
            const calc = createCalculator();
            calc.appendNumber('5');
            calc.chooseOperation('+');
            calc.appendNumber('3');
            calc.clear();
            assert(calc.currentOperand === '0', 'Should reset to 0');
            assert(calc.previousOperand === '', 'Previous operand should be empty');
            assert(calc.operation === undefined, 'Operation should be undefined');
        });

        runner.test('Delete removes last digit', () => {
            const calc = createCalculator();
            calc.appendNumber('1');
            calc.appendNumber('2');
            calc.appendNumber('3');
            calc.delete();
            assert(calc.currentOperand === '12', 'Should display 12');
        });

        runner.test('Delete on single digit shows zero', () => {
            const calc = createCalculator();
            calc.appendNumber('5');
            calc.delete();
            assert(calc.currentOperand === '0', 'Should display 0');
        });

        runner.test('Chain operations work correctly', () => {
            const calc = createCalculator();
            calc.appendNumber('5');
            calc.chooseOperation('+');
            calc.appendNumber('3');
            calc.chooseOperation('*');
            calc.appendNumber('2');
            calc.compute();
            assert(calc.currentOperand === '16', 'Should equal 16 (5+3=8, 8*2=16)');
        });

        runner.test('Handles decimal calculations', () => {
            const calc = createCalculator();
            calc.appendNumber('0');
            calc.appendNumber('.');
            calc.appendNumber('1');
            calc.chooseOperation('+');
            calc.appendNumber('0');
            calc.appendNumber('.');
            calc.appendNumber('2');
            calc.compute();
            assert(calc.currentOperand === '0.3', 'Should equal 0.3');
        });

        runner.test('Handles negative results', () => {
            const calc = createCalculator();
            calc.appendNumber('5');
            calc.chooseOperation('-');
            calc.appendNumber('1');
            calc.appendNumber('0');
            calc.compute();
            assert(calc.currentOperand === '-5', 'Should equal -5');
        });

        runner.test('Rounds floating point precision errors', () => {
            const calc = createCalculator();
            const result = calc.roundResult(0.1 + 0.2);
            assert(result === 0.3, 'Should properly round 0.1 + 0.2 to 0.3');
        });

        runner.test('Formats numbers with thousands separators', () => {
            const calc = createCalculator();
            const formatted = calc.getDisplayNumber('1000');
            assert(formatted === '1,000', 'Should format with comma separator');
        });

        runner.test('Operation symbols display correctly', () => {
            const calc = createCalculator();
            assert(calc.getOperationSymbol('+') === '+', 'Plus should display +');
            assert(calc.getOperationSymbol('-') === '−', 'Minus should display −');
            assert(calc.getOperationSymbol('*') === '×', 'Multiply should display ×');
            assert(calc.getOperationSymbol('/') === '÷', 'Divide should display ÷');
        });

        // Helper to create a calculator instance for testing
        function createCalculator() {
            const mockDiv = document.createElement('div');
            return new Calculator(mockDiv, mockDiv);
        }

        // Include the Calculator class for testing
        class Calculator {
            constructor(previousDisplayElement, currentDisplayElement) {
                this.previousDisplayElement = previousDisplayElement;
                this.currentDisplayElement = currentDisplayElement;
                this.clear();
            }

            clear() {
                this.currentOperand = '0';
                this.previousOperand = '';
                this.operation = undefined;
                this.shouldResetDisplay = false;
            }

            delete() {
                if (this.shouldResetDisplay) return;
                if (this.currentOperand.length === 1) {
                    this.currentOperand = '0';
                } else {
                    this.currentOperand = this.currentOperand.slice(0, -1);
                }
            }

            appendNumber(number) {
                if (this.shouldResetDisplay) {
                    this.currentOperand = '0';
                    this.shouldResetDisplay = false;
                }

                if (number === '.' && this.currentOperand.includes('.')) return;

                if (this.currentOperand === '0' && number !== '.') {
                    this.currentOperand = number;
                } else {
                    this.currentOperand += number;
                }
            }

            chooseOperation(operation) {
                if (this.previousOperand !== '' && !this.shouldResetDisplay) {
                    this.compute();
                }

                this.operation = operation;
                this.previousOperand = this.currentOperand;
                this.shouldResetDisplay = true;
            }

            compute() {
                let computation;
                const prev = parseFloat(this.previousOperand);
                const current = parseFloat(this.currentOperand);

                if (isNaN(prev) || isNaN(current)) return;

                switch (this.operation) {
                    case '+':
                        computation = prev + current;
                        break;
                    case '-':
                        computation = prev - current;
                        break;
                    case '*':
                        computation = prev * current;
                        break;
                    case '/':
                        if (current === 0) {
                            this.currentOperand = 'Cannot divide by zero';
                            this.previousOperand = '';
                            this.operation = undefined;
                            this.shouldResetDisplay = true;
                            return;
                        }
                        computation = prev / current;
                        break;
                    default:
                        return;
                }

                if (!isFinite(computation)) {
                    this.currentOperand = 'Result is too large';
                    this.previousOperand = '';
                    this.operation = undefined;
                    this.shouldResetDisplay = true;
                    return;
                }

                computation = this.roundResult(computation);
                this.currentOperand = computation.toString();
                this.operation = undefined;
                this.previousOperand = '';
                this.shouldResetDisplay = true;
            }

            roundResult(number) {
                return Math.round(number * 10000000000) / 10000000000;
            }

            getDisplayNumber(number) {
                const stringNumber = number.toString();
                const integerDigits = parseFloat(stringNumber.split('.')[0]);
                const decimalDigits = stringNumber.split('.')[1];

                let integerDisplay;

                if (isNaN(integerDigits)) {
                    integerDisplay = '';
                } else {
                    integerDisplay = integerDigits.toLocaleString('en', {
                        maximumFractionDigits: 0
                    });
                }

                if (decimalDigits != null) {
                    return `${integerDisplay}.${decimalDigits}`;
                } else {
                    return integerDisplay;
                }
            }

            getOperationSymbol(operation) {
                const symbols = {
                    '+': '+',
                    '-': '−',
                    '*': '×',
                    '/': '÷'
                };
                return symbols[operation] || operation;
            }
        }

        // Run tests function
        function runAllTests() {
            runner.runAll();
        }

        // Auto-run tests on load
        window.addEventListener('load', runAllTests);
    </script>
</body>
</html>
